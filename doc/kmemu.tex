% LTeX: language=en-US
\documentclass[10pt,a4paper,final]{article}
\usepackage{a4wide}
\usepackage[czech,english]{babel}
\usepackage{hyphsubst}
\usepackage{xevlna}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{amsmath}
\usepackage{esvect}
\usepackage{parskip}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage{underscore}
\usepackage{enumitem}
\usepackage{minted}

\PassOptionsToPackage{hyphens}{url}

\usepackage[pdfborderstyle={/S/U/W 1}]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={KMEMU - MISC CPU Computer Emulator},
}
\urlstyle{same}

% define helper command for typesetting code
\newcommand{\code}[1]{\texttt{#1}}

\chardef\_=`_

\newlist{notes}{enumerate}{1}
\setlist[notes]{label=Note: ,leftmargin=*}
\newenvironment{note}[1]{\begin{notes}\item #1}{\end{notes}}

\usemintedstyle{friendly}

% increase spacing between table rows
\renewcommand{\arraystretch}{1.25}

\selectlanguage{english}

\begin{document}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{pic/kiv-cmyk-en}
\end{figure}

\vspace{.5cm}

\begin{center}
	\LARGE{KMEMU -- MISC CPU Computer Emulator}\\
	\vspace{.5cm}
	\large{Semester project -- KIV/PC 2024/25}
\end{center}

\vfill

\noindent
University of West Bohemia in Pilsen \hfill Pavel Altmann -- A23B0264P\\
Department of Computer Science and Engineering \hfill \today
\thispagestyle{empty}

\newpage
\setcounter{page}{1}

\tableofcontents

\newpage

\section{Assignment}
\label{sec:assignment}
\begin{otherlanguage}{czech}

Naprogramujte v ANSI C přenositelnou \textbf{konzolovou aplikaci}, v podstatě
jednoduchý, ale plně funkční, \textit{emulátor} teoretického počítače – nazvěme
ho třeba K’s Machine (KM) – s procesorem architektury MISC (= Minimal
Instruction Set Computer), který bude na hostitelském počítači vykonávat
programy (v binární podobě, tj. ve strojovém kódu) pro níže popsaný
minimalistický teoretický počítač.

Emulátor se bude spouštět příkazem

\begin{quotation}
\code{X:\textbackslash>kmemu.exe \textlangle program.kmx\textrangle
[\textlangle výstupní soubor[.txt]\textrangle]}
\end{quotation}

Symbol \code{\textlangle program ve strojovém kódu\textrangle} zastupuje povinný
parametr – název vstupního binárního souboru s programem ve strojovém kódu pro
procesor KM. Přípona \code{.kmx} (\foreignlanguage{english}{= \underline{K}’s
\underline{M}achine E\underline{x}ecutable}; obdoba windowsovského \code{.exe},
\foreignlanguage{english}{= \underline{Exe}cutable}), označující spustitelný
soubor pro náš teoretický procesor, musí být vždy uvedena. Symbol
\code{\textlangle výstupní soubor\textrangle} pak představuje nepovinný
parametr, kterým je jméno textového souboru, do kterého se bude ukládat výstup
při vykonávání programu, tj. informace/hodnoty, které emulátor vypisuje na
obrazovku při vykonávání instrukcí programu. Není-li druhý, nepovinný, parametr
uveden, směrujte výstup emulátoru do konzole (do standardního streamu
\code{stdout}).

Úkolem Vámi vyvinutého programu tedy bude:

\begin{enumerate}
\item Načíst prvním parametrem určený spustitelný soubor (program) ve strojovém
    kódu ve formátu KMX pro níže popsaný teoretický procesor. \\
\item Vytvořit (podle údajů uložených ve spustitelném souboru) kódový a datový
    segment pro běh programu. \\
\item Vykonat program uložený v kódovém segmentu provedením všech jeho
    instrukcí, včetně smyček, volání podprogramů, atd. \\
\item Provádí-li se právě instrukce, jejímž úkolem je vypsat nějaký údaj na
    obrazovku, vypsat tento údaj do konzole, případně (je-li při spuštění
    programu uveden nepovinný druhý parametr) uložit do specifikovaného
    výstupního textového souboru. \\
\item Po dokončení vykonávání programu uvolnit paměť obsazenou datovým a kódovým
segmentem vykonávaného programu a následně emulátor ukončit. \\

\end{enumerate}

Váš program může být během testování spuštěn například takto (v operačním
systému Windows):


\begin{quotation}
\code{X:\textbackslash>kmemu.exe "E:\textbackslash My Work\textbackslash
Test\textbackslash mersenne.kmx"\ mersenne.txt}
\end{quotation}

Uvažujte všechny možné specifikace (uvedení úplné cesty, relativní cesty, atp.)
jak vstupního, tak výstupního souboru, které jsou přípustné v daném operačním
systému. Pokud nebude na příkazové řádce uveden alespoň jeden parametr (tj.
jméno binárního spustitelného souboru ve formátu KMX), vypište chybové hlášení a
stručný návod k použití programu (v angličtině). Návratová hodnota funkce
\code{int main(...)} bude v tomto případě 1.

\end{otherlanguage}

\section{Problem analysis}
\label{sec:analysis}

Algorithmically, the assignment is relatively straightforward. It is
fundamentally a while loop, that executes the current instruction and, if
applicable, moves to the next one until either the \code{HALT} instruction is
encountered or the end of a file (\code{EOF}) is reached, or an error is
detected.

The primary challenge of the assignment is, in my opinion, the management of raw
binary data---everything from reading of the input file to addressing both
individual bytes and four-byte integers within a virtual memory. A closely
related concern is the necessary prevention of any out-of-bounds access to the
memory.

Another difficulty is the inherent repetition of code for each instruction,
since they all generally need to do the whole read-evaluate-write loop with only
minor variations. This could be solved most effectively by polymorphism and
higher-order functions, but that's not available in C. Consequently, alternative
methods for code reuse, such as helper functions or, more likely, macros, must
be employed. However, caution must be exercised to avoid overuse and thereby
ensuring the code remains comprehensible and easy to debug.

\section{Implementation}
\label{sec:impl}

The internal state of the emulated computer is stored in a \code{struct} called
\hyperlink{vm}{\code{VM}} (virtual machine). This struct holds all relevant
data, such as registers (in a \hyperlink{registers}{\code{Registers}} struct),
data, code and stack segments (and their sizes), the instruction pointer
(\code{IP}), and a few other helper variables.

The program code is then segmented into two parts: driver code (the
\code{src/vm.c} file) and VM code (the \code{src/instructions} subdirectory).
The driver code handles CLI, IO and calling the relevant VM code, which in turn
handles the execution of the individual instructions itself and the relevant
state changes. 

\subsection{Data Structures}

The program does not utilize any complicated data structures; it employs
primarily plain-old-data\footnote{also known as passive data structures}
containers accompanied by relevant functions in OOP-like style (first parameter
being a pointer to the struct).

Main data structure of the program is the \hypertarget{vm}{\code{struct VM}}
defined in \code{src/vm.h} as follows:

\begin{center}
\begin{tikzpicture}
    \begin{class}[text width=8cm]{VM}{0,0}
        \attribute{\code{registers} : \code{Registers}}
        \attribute{\code{IP} : \code{size\_t}}
        \attribute{\code{code_segment} : \code{Byte*}}
        \attribute{\code{code_size} : \code{size_t}}
        \attribute{\code{data_segment} : \code{Byte*}}
        \attribute{\code{data_size} : \code{size_t}}
        \attribute{\code{stack_segment} : \code{Byte*}}
        \attribute{\code{stack_size} : \code{size_t}}
        \attribute{\code{error_msg} : \code{char*}}
        \attribute{\code{output} : \code{FILE*}}
        \attribute{\code{flags} : \code{unsigned char}}
        \attribute{\code{instructions_count} : \code{size_t}}
        \attribute{\code{debug} : \code{DebugLevel}}

        \operation{\code{vm_run(VM *vm)} : \code{int}}
        \operation{\code{vm_print(VM *vm)} : \code{void}}
        \operation{\code{vm_free(VM *vm)} : \code{void}}
    \end{class}
\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \code{registers} -- registers stored in a \code{struct} called
        \hyperlink{registers}{\code{Registers}} (further details below). 
    \item \code{*_segment} -- memory segments stored as \code{Byte} arrays, with
        sizes stored in respective \code{*_size} fields.
    \item \code{IP} -- instruction pointer, points to the current instruction in
        the \code{code_segment}.
    \item \code{error_msg} -- a buffer for error messages, preallocated to
        \code{VM_ERROR_BUFFER_SIZE}.
    \item \code{output} -- a pointer to the file to which the output should be
        written.
    \item \code{flags} -- a bitfield indicating conditions; set by the \code{CMP}
        instruction, read by conditional jumps and zeroed otherwise. For
        possible values, see the \code{FLAG} enum.
    \item \code{instructions_count} -- the count of executed instructions, used
        for debugging.
    \item \code{debug} -- a flag indicating whether to print debug messages.
\end{itemize}

\begin{note}
\code{Word} is an alias for \code{signed long int} -- a word of the K's Machine
-- and \code{Byte} is an alias for \code{unsigned char} -- a one byte.
\end{note}

The \hypertarget{registers}{\code{Registers}} struct is defined as follows 

\begin{center}
\begin{tikzpicture}
    \begin{class}[text width=10cm]{Registers}{0,0}
        \attribute{\code{A} : \code{Word}}
        \attribute{\code{B} : \code{Word}}
        \attribute{\code{C} : \code{Word}}
        \attribute{\code{D} : \code{Word}}
        \attribute{\code{S} : \code{Word}}
        \attribute{\code{SP} : \code{Word}}

        \operation{\code{vm_get_reg(VM *vm, Byte reg, Word *out)} : \code{int}}
        \operation{\code{vm_set_reg(VM *vm, Byte reg, Word value)} : \code{void}}
    \end{class}
\end{tikzpicture}
\end{center}

\subsection{Algorithms}
\label{sec:algorithms}

Similarly to data structures, the assignment did not require complex algorithms.
The primary algorithm, which constitutes the core of the program, is a
straightforward infinite loop. During each iteration of this loop, a single byte
is read from the code segment, and control is transferred to the corresponding
handler function. 

\subsection{Instructions}
\label{sec:instructions}

All instruction handlers operate on a very simple basis: they load inputs from
the code segment, execute an operation, store the result in either registers or
the data segment of the memory and return control to the main loop. 

\subsubsection{Handler Contract}
\label{sec:contract}

All instruction handlers adhere to a simple implicit contract that dictates the
handling of the \code{VM} struct with following rules:

\begin{itemize}
    \item Handler is allowed to modify fields \code{IP}, \code{registers},
        \code{flags}, and \code{error_msg}.
    \item When a handler is called, the \code{IP} is pointing to the byte
        immediately following the op-code byte. 
    \item When the control is returned to the main loop, the instruction pointer
        should point to the next instruction to be executed.
    \item The handler should return status code according to the
        \nameref{sec:errors} section.
\end{itemize}



\subsubsection{Repetition}
\label{sec:repetition}

As indicated in the problem analysis section, a significant effort was invested
in the elimination of repetition in the implementation of the individual
instructions. Initially, only helper functions were used; however, these still
necessitated a substantial amount of boilerplate code, particularly for error
handling and propagation. Eventually, a rewrite of the instruction handlers into
macros was implemented, which enabled for example the definition of any binary
operation instruction handler on a single line, given only the name and
operator. For more details, see the section \nameref{sec:macros} below.

This approach yielded a code that was almost two times shorter than the one
created using the helper functions, while simultaneously enhancing the
readability of the definitions. On the other hand, this approach resulted in
over 100 lines of nested macro definitions, which rendered the part of the
codebase rather complicated and difficult to debug. Nevertheless, in my opinion
the advantages of this approach outweigh the disadvantages, especially given
that the project does not require long-term support and therefore
maintainability is not a major concern.

\subsection{Macros}
\label{sec:macros}

Due to inherent repetitiveness of the instruction handlers, it was necessary to
define a set of macros to make the code more readable and maintainable. Thus,
most of the used macros are applicable to the context of the instruction
handlers and expect a \code{vm} in the calling scope. Only exception is the
\code{INSTRUCTION} family of macros that define the \code{vm} variable as a
handler parameter.

\subsubsection{Macro conventions}
\label{sec:macrosconventions}

Macros that "return" or "propagate" do so from the calling scope to its caller
-- that is, they expand to a \code{return} statement.

The general conventions for macro arguments naming, specific use case is in the
comment at the beginning of the macro definition:

\begin{itemize}
    \item \code{reg} -- a register
    \item \code{reg1} -- the first register
    \item \code{reg2} -- the second register
    \item \code{reg_s} -- the source register
    \item \code{reg_d} -- the destination register
    \item \code{address} -- a memory address
    \item \code{type} -- the data type for \code{var} declaration or for
        \code{sizeof} when accessing memory
    \item \code{var} -- the variable identifier to be defined, written to or read
    \item \code{val} -- the value to be processed
    \item \code{code} -- the code to be executed
\end{itemize}

\subsubsection{List of defined macros}
\label{sec:macroslist}

A non-exhaustive list of the most important macros used in the instruction
handlers implementations:

\begin{itemize}
    \item \code{DEBUG_PRINT(...)} -- if \code{vm->debug} is not equal to
        \code{DEBUG_NONE}, print the \code{...} arguments using \code{printf}.
    \item \code{DEBUG_PRINT_INSTRUCTION(name, reg1, reg2)} -- print debug
        representation of the given register-register instruction.
    \item \code{DEBUG_PRINT_INSTRUCTION_IM(name, reg, im)} -- print debug
        representation of the given register-immediate instruction.

    \item \code{INSTRUCTION(name, code)} -- define a handler for an instruction
        called \code{name} with \code{code} as body.
\end{itemize}

\begin{note}
    See also the section \nameref{sec:errors} for a list of error related
    macros.
\end{note}

\subsection{Error handling}
\label{sec:errors}

As previously stated in the \nameref{sec:repetition} section, the KMEMU emulator
employs error handling through the use of macros, which streamline the process
of checking conditions and propagating errors. The \code{ASSERT} macro, for
example, is used to verify conditions and throw human-readable errors if they
are not met. Full list of related macros is provided below:

\begin{itemize}
\item \code{TRY(code)} -- execute \code{code} and if an error occurs, propagate
    it to the caller by returning the error code.
\item \code{THROW_ERROR(code, ...)} -- returns the error \code{code} to the
    caller and sets the \code{vm->error_msg} using \code{sprintf}.
\item \code{ASSERT(condition, ...)} -- checks \code{condition} and if it
    evaluates to \code{false}, throws an error using \code{THROW_ERROR} with
    code \code{EXIT_FAILURE} from the \code{stdlib.h} header.
\end{itemize}

An illustration of a practical use of the error handling macros is provided by
the following example of the \code{ret} instruction implementation:

\begin{minted}{c}
INSTRUCTION(ret, {
  DEBUG_PRINT("RET\n");
  ASSERT(vm->registers.SP > 0, "Return from empty stack");
  Word address;
  TRY(pop(vm, &address));
  ASSERT(address >= 0 && (size_t)address < vm->code_size,
         "Return to invalid address 0x%08X", address);
  vm->IP = address;
})
\end{minted}

In the example, the \code{ASSERT} macro initially verifies that the stack is not
empty before attempting to pop a value from it. If the condition fails, an error
message is generated, and the error is propagated back to the caller.
Subsequently, the \code{TRY} macro is employed to execute the pop operation
itself, and if an error occurs (for instance, if the \code{vm->SP} points beyond
the end of the stack), it is propagated back to the caller. Finally, the
\code{ASSERT} macro is utilized to verify that the popped address is a valid
address within the code segment.

The utilization of error handling macros ensures consistent error handling
throughout the emulator, thereby enhancing the clarity and safety of the code
while simultaneously providing clear and informative error messages to the user.

This approach simplifies code by reducing boilerplate and ensures consistent
error handling throughout the emulator. The use of macros such as \code{ASSERT}
and \code{THROW_ERROR} provides clear and concise error handling, enhancing the
clarity and safety of the code.

\subsubsection{Error messages}
\label{sec:errormessages}

Human-readable error messages are propagated through the \code{vm->error_msg}
buffer, which is preallocated to \code{VM_ERROR_BUFFER_SIZE} bytes during the
initialization of the \code{VM} struct. As a convention, this field may be
reallocated arbitrarily; however, it is imperative that the new size does not
fall below the \code{VM_ERROR_BUFFER_SIZE}, and that the previous allocation is
freed.

\subsubsection{Error and exit codes}
\label{sec:errorcodes}

Within the emulator only two error codes are utilized: \code{EXIT_SUCCESS} and
\code{EXIT_FAILURE} from the \code{stdlib.h} header.

This stands in contrast to the user-facing exit codes defined in the file
\code{src/defs.h}:

\begin{itemize}
    \item \code{EXIT_SUCCESS = 0}: Indicates successful program execution.
    \item \code{EXIT_ARGS = 1}: Indicates an issue with the program's arguments.
    \item \code{EXIT_FILE = 2}: Indicates an error related to the format of the
        input file.
    \item \code{EXIT_UNKNOWN = 3}: Indicates an unknown instruction.
    \item \code{EXIT_EXEC = 4}: Indicates an error during program execution,
        such as attempted division by zero or out-of-bounds memory access.
    \item \code{EXIT_MEMORY = 128}: Indicates a host memory-related error,
        usually due to a \code{malloc} call returning \code{NULL}.
\end{itemize}

\section{User manual}
\label{sec:manual}

The KMEMU program provides a command-line interface (CLI) that allows users to
load and execute programs written in the KMX format as defined in the problem
statement. 

The CLI accepts the following signature:

\begin{quotation}
\code{X:\textbackslash> kmemu.exe \textlangle input_file\textrangle\ 
[\textlangle output_file\textrangle]}
\end{quotation}


\begin{itemize}
    \item \code{\textlangle input_file\textrangle} -- the path to the KMX file to
        be loaded and executed. 
    \item \code{\textlangle output_file\textrangle} (optional) -- the path to the
        file to which the program output should be written. If omitted, the
        output is written to the standard output.
\end{itemize}

Additionally, the program also reads the \code{DEBUG} environment variable. The
following values are accepted as defined in the \code{DebugLevel} enum:

\begin{itemize}
    \item \code{0} or unset -- no debug messages
    \item \code{1} -- print executed instructions
    \item \code{2} -- print executed instructions, state of the memory after each
        instruction and the runtime information
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

In summary, my KMEMU project accomplished its primary objective of developing a
functional emulator for the theoretical K's Machine with a MISC architecture.
The emulator was implemented in C 99, ensuring high portability across different
platforms. The key results achieved include:

\begin{itemize}
    \item \textbf{Functionality}: The emulator correctly executes programs
        written in the KMX format, handling all specified instructions,
        including arithmetic, memory access, conditionals, control flow and
        subroutine calls.
    \item \textbf{Performance}: The emulator demonstrated adequate performance
        with reasonable times observed on various test programs on the
        development machine, with an approximate runtime of 12 nanoseconds per
        instruction. Specifically, the sample bubble sort program ran on average
        for 459 microseconds.
    \item \textbf{Error Handling}: Robust error handling mechanisms were
        implemented to manage invalid instructions, out-of-bounds memory access,
        and other potential issues.
\end{itemize}

The assignment was completed successfully, meeting all the specified
requirements. The emulator has been verified through testing and the validator
system to be able to load and execute binary programs in the KMX format and
produce output either to the console or a specified file. Additionally, the
program provides reasonably helpful error messages and usage instructions when
incorrect parameters are provided.

However, two areas were identified where improvements could be made:

\begin{itemize}
    \item \textbf{Testing}: Although the project was successfully validated,
        more extensive testing with a wider range of programs would facilitate
        the identification and fix any potential edge cases or bugs that may
        still be present. Especially handling of invalid or otherwise unexpected
        inputs/programs (e.g., empty file, large file, jumps near bounds, stack
        manipulations, etc.).
    \item \textbf{Code Maintenance}: The use of macros for instruction handling,
        while having significantly reduced code repetition, has also resulted in
        parts of the codebase becoming complex. It is therefore recommended that
        these sections undergo refactoring for the purpose of enhancing
        readability, in order to ensure better long-term maintainability.
\end{itemize}

During the development of this project, several challenges were encountered,
including managing raw binary data, preventing out-of-bounds memory access, and
reducing code duplication for instruction handling. These challenges were
addressed through careful design and the use of helper functions and later
macros.

The development of KMEMU probed to be a valuable learning experience, offering
insights into emulator development, C and assembly programming, and macro-based
metaprogramming. Additionally, and perhaps most significantly, it was a very
enjoyable project to work on.

\end{document}
